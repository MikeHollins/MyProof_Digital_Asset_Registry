Below is a **complete product brief** for your Replit agent: what **MyProof Registry (PAR)** is meant to do, every **feature** it should include, who it is **built for**, and the **engineering scope** to ensure nothing is missed. Treat this as the **PRD/SRS** your agent implements and checks against.

---

# 1) One-line mission

**MyProof Registry** provides a **privacy-first, credential-agnostic, reusable verification layer**: verify once, **re-verify** anywhere using a **signed receipt** and a **W3C status list**—with **zero PII storage**, **tamper-evident audit**, and **fine-grained partner controls**.

---

# 2) Core value proposition

* **Frictionless reuse:** Partners don’t need to re-collect sensitive data; they can **re-verify** using a **verifier-signed receipt** (`verifier_proof_ref`) bound to immutable commitments and status.
* **Privacy by design:** Stores only **hashes/CIDs/DIDs/status pointers**. **Never** stores PII or raw proof payloads.
* **Revocation at scale:** One **bit flip** in a **W3C bitstring status list** revokes/suspends a credential globally.
* **Audit-ready:** Append-only log with exportable evidence; auditors can verify without seeing personal data.
* **Interoperable & future-proof:** Works with **W3C VC (JWT/LD-Proof)**, **ZK proofs**, **HW attestations**, **Merkle proofs**, and **blockchain tx proofs**.

---

# 3) Who it’s for (target customers/partners)

* **Ticketing & venues:** anti-scalp, presale eligibility, attendance verification, reusable fan receipts.
* **Insurance & benefits:** wellness/activity validation, usage-based eligibility, discount receipts.
* **Age-restricted commerce & entertainment:** 18+/21+ zero-knowledge age receipts.
* **Financial/KYC/AML (lightweight)**: “KYC verified” receipts without exposing raw identity data.
* **Healthcare/fleet/workforce compliance:** fitness-for-duty or certification receipts (no PHI storage).
* **Education/certification:** skills/credential receipts; revocation for fraud or expiry.
* **Supply chain & IoT access:** device attestations and operational access control.

---

# 4) Roles & operating modes

**Roles:** Issuer, Holder, Verifier, Registry Operator (MyProof).
**Mint trigger:** a **successful proof verification event** issues a **signed receipt**; the registry “mints” a reusable record bound to that event.

**Operating modes (choose per partner/tenant with scopes):**

1. **Partner-mint:** partner verifies and calls mint.
2. **Operator-mint:** MyProof verifies + mints for partner (managed/concierge).
3. **Consume-only:** partner does **re-verify** only on already minted records.

---

# 5) Canonical core term (authoritative)

> **`verifier_proof_ref` — a reference to a verifiable cryptographic proof or attestation generated by a verifier or equivalent entity, comprising any mathematically verifiable construct that demonstrates authenticity, integrity, correctness, or origin of a claimed verification event or data state, including but not limited to digital signatures, zero-knowledge proofs, hardware or firmware attestations, authenticated message digests, Merkle-based inclusion or exclusion proofs, blockchain-anchored confirmations, or any cryptographically secure verification primitive functionally equivalent thereto.**

---

# 6) High-level architecture

* **API Gateway** (Express/TS): strict schemas, idempotency, mTLS (service-to-service), OIDC for operator console (prod), API keys for partners.
* **Proof Intake/Validation**: accepts `verifier_proof_ref` (receipt), verifies JOSE, enforces policy.
* **Policy & Constraint Store**: artifacts are **CID-pinned**; registry binds policy to each mint.
* **Status List Service**: **W3C bitstring status list** (revocation/suspension) with ETag & fail-closed logic; persisted in DB.
* **License/Usage**: optional permitted_use_count/time windows; optional royalty descriptors; usage receipts.
* **Transfer/Provenance**: optional ownership change with audited provenance.
* **Transparency Log**: append-only event log; rolling Merkle root (exportable for auditors).
* **Key Management**: verifier signer lives in Verifier service (prod); registry verifies via JWKS; **API Keys / Rotation** for partners/operators.
* **DB**: Postgres (assets, status lists, API keys, partners, audit events, jti replay); Redis optional for rate limits (DB fallback for demos).

---

# 7) Data model (key entities)

* **ProofAsset**

  * `proof_asset_id` (UUID), `proof_asset_commitment` (RFC 8785 canonical JSON digest)
  * `issuer_did`, optional `subject_binding` (no PII)
  * `proof_format` (VC_JWT | VC_LD_PROOF | SD_JWT_VC | ZK_PROOF | HW_ATTESTATION | MERKLE_PROOF | BLOCKCHAIN_TX_PROOF | OTHER)
  * `verifier_proof_ref` (digest + uri + alg)
  * `policy_hash` + `policy_cid`, `constraint_hash` (+ optional `constraint_cid`)
  * `status_ref` { `statusListUrl`, `statusListIndex`, `statusPurpose` }
  * `license` (optional), `verification_status` (‘verified’/‘revoked’/‘suspended’), timestamps
* **StatusList**

  * `url` (PK), `purpose`, `bits` (bytea), `etag`, `updated_at`, `bit_length`
* **Partners**

  * `partner_id`, `name`, `active`, `contact_email`, timestamps
* **ApiKeys**

  * `key_id` (mpk_*), `partner_id`, `secret_hash` (Argon2id + pepper), `scopes`, `status`, `not_before`, `not_after`, `rate_per_minute`, `last_used_at`
* **JTI Replay**

  * `jti` (PK), `exp_at` (for receipt replay protection)
* **AuditEvents**

  * `event_id`, `event_type` (‘MINT’/‘USE’/‘TRANSFER’/‘STATUS_UPDATE’), `asset_id`, `payload` (PII-free), `leaf_hash`, `created_at`

---

# 8) Critical features (what must exist)

## 8.1 Verification & minting

* **Verify** received proof and issue **receipt** (separate verifier service in prod; demo signer in dev).
* **Mint** proof asset bound to: `proof_digest`, `policy_hash`, `constraint_hash`, `status_ref`.

## 8.2 Re-verification (fast path + fresh policy)

* **Fast path**: Validate **receipt** (JOSE allow-list, `typ=JWT`, no `crit`, `aud/nbf/exp/jti`), triple-bind **status_ref** (url/index/purpose), **fail-closed** if status list unreachable/stale; match commitments; consult `verification_status` (monotonic).
* **Fresh policy**: If policy demands fresh crypto, accept **proof_bytes** or **proof_uri**; **SRI** digest pin, host allow-list, timeout, size cap; verify by format and **discard** bytes.

## 8.3 Status lists (revocation/suspension)

* DB-backed **bitstring** with **ETag**; GET endpoint serves binary; POST update flips bits.
* **Fail-closed**: if list unavailable or stale beyond threshold → `verdict: rejected/unknown`.

## 8.4 Policy/constraints & CIDs

* Bind **CID-pinned** policies/constraints at mint; canonicalize inputs via **RFC 8785** before hashing/signing to prevent drift.
* Persist **digest algorithm** and enforce encoding normalization (hex in DB, base64url in receipts recommended).

## 8.5 Audit & transparency

* Append-only audit events; optional rolling **Merkle root**; snapshot export for auditors.

## 8.6 API keys / rotation (partner & operator)

* Issue/rotate/revoke **API keys** (Argon2id + pepper; one-time token display); per-route **scopes** (`assets:mint`, `assets:read`, `status:update`, `transfer:execute`, `audit:read`, `admin:*`).
* Rate-limit by **key_id** + IP; log redaction (no secrets).

## 8.7 Admin console / developer portal (UI)

* **Dashboard**: counts, recent events.
* **Proof Assets**: list/search/filter; show commitments, policy/constraint hashes, status.
* **Verification**: paste receipt to re-verify; toggle fresh-proof policy for demos.
* **Status Lists**: view/update bits; display `ETag` + `updated_at`.
* **Audit Logs**: filter by asset; export snapshot.
* **API Keys / Rotation**: list/issue/rotate/revoke; partner filter; security notes; (optional) **Receipt Signer** subpanel (kid/alg/rotate).
* **Settings**: env info, JWKS URL, CID policies; (dev) set **admin token** for admin routes.

## 8.8 Persistence of live state (restart proof)

* **Status lists**, **jti replay**, **assets verification_status** must persist in Postgres (no in-memory only).
* Optional Redis for rate limiting; DB fallback allowed.

---

# 9) Security & privacy baseline (non-negotiables)

* **Zero PII storage**: only store **hashes/CIDs/DIDs/status pointers/receipts**.
* **JOSE strictness** for receipts: allow-list alg (ES256 now; add EdDSA later), `typ='JWT'`, reject `crit`, enforce `aud/nbf/exp`, `jti` replay cache (DB).
* **Status fail-closed** and **ETag** caching; staleness threshold.
* **Canonicalization** via **RFC 8785** for any hashed/signed JSON.
* **SRI** for fetched proofs; timeout & size caps; **discard** proof bytes after verify.
* **API keys**: Argon2id + pepper; one-time token display; **never** log secrets; least-privilege scopes; rate limits.
* **CSP/HSTS**: nonce-based CSP; no `unsafe-inline`; redacted logs.
* **Auditability**: append-only logs; exportable snapshot; optional Merkle root.

---

# 10) APIs (minimal contract)

* **POST** `/api/proof-assets` (mint) — `assets:mint`
* **POST** `/api/proof-assets/:id/verify` (re-verify) — `assets:read` or `reverify:read`
* **GET** `/api/proof-assets/:id` — `assets:read`
* **POST** `/api/status-lists/:purpose/update` — `status:update`
* **GET** `/status/lists/:purpose/:listId` — binary with ETag (public or protected)
* **POST** `/api/proof-assets/:id/transfer` — `transfer:execute`
* **GET** `/api/audit-events` — `audit:read`
* **Admin:** `/api/admin/partners` (GET/POST), `/api/admin/api-keys` (GET), `/api/admin/api-keys/issue` (POST), `/api/admin/api-keys/:keyId/rotate|revoke` (POST)
* **Optional verifier signer** admin endpoints (if combined with this service in dev).

---

# 11) UI pages (final list)

* **Dashboard**, **Proof Assets**, **Verification**, **Status Lists**, **Audit Logs**, **API Keys / Rotation**, **Settings**
* Optional **Demo** helper: Seed → Verify → Revoke → Verify (valid→revoked) with local status list URL persisted in DB.

---

# 12) Modes, credentials, policies

* Credential types selectable: **VC_JWT**, **VC_LD_PROOF**, **SD_JWT_VC**, **ZK_PROOF**, **HW_ATTESTATION**, **MERKLE_PROOF**, **BLOCKCHAIN_TX_PROOF**, **OTHER**.
* Policy flag **`requireFreshProof`** triggers fresh path; provide `proof_uri` or `proof_bytes` input.
* **CID-pinned** policies/constraints; canonical hashing.

---

# 13) Observability & ops

* OpenTelemetry traces; RED/USE metrics; error budget alerts.
* Status list health (freshness), signer key age, API key usage (per partner).
* Backups: Postgres PITR; monthly restore test.
* Pen-tests before GA; SOC2/ISO templates (DPIA, ROPA included).

---

# 14) Test plan (minimum)

* Receipt JOSE rejections: missing `aud`, expired `exp`, future `nbf`, `alg` not allowed, `typ` mismatch, `crit` present, missing `jti`, replayed `jti`.
* Triple bind mismatch (`url/index/purpose`) → reject.
* Status list unreachable/stale → fail-closed.
* Digest encoding mismatch (hex vs base64url) → normalized compare passes.
* Fresh path SRI mismatch → reject before verifier.
* API key: invalid format, revoked, expired, wrong scopes → 401/403.
* Admin flows: issue/rotate/revoke keys; first bootstrap.
* Persistence across restarts: status bit, jti replay, asset verification_status.

---

# 15) Out of scope (for v1)

* Storing or processing raw PII / PHI.
* Full credential issuance wallets (we only verify/mint receipts).
* Multi-cloud signing HSM orchestration (use a single KMS/HSM in v1).
* Public blockchain anchoring (optional later).

---

# 16) Agent acceptance checklist

* [ ] All endpoints implemented and **schema-validated**.
* [ ] **No PII** in DB, logs, telemetry.
* [ ] Status lists are **DB-backed** with ETag; **fail-closed** enforced.
* [ ] Receipts pass JOSE strictness; **replay (JTI) persisted**.
* [ ] **API keys**: Argon2id + pepper, one-time display, scopes enforced; admin console works.
* [ ] **CID** + **RFC 8785 canonicalization** used wherever hashing/signing.
* [ ] **UI** has all pages and is accessible (WCAG basics).
* [ ] **Tests** cover receipt, status, digest, API keys, persistence.
* [ ] **Docs**: Partner Onboarding, Client Integration, Audit Model, DPIA/ROPA templates.

---

## Final note

This spec captures everything PAR is meant to do, every feature it should have at GA, and the exact customers it serves—**without missing any of the privacy, security, or persistence guarantees**. If you want this converted into a task board (agent-ready subtasks with file paths), I’ll output a **phase-by-phase checklist** next.
